"""Useful functions for I/O actions."""

import os
import rasterio
import sys
import errno
import pickle
import numpy as np
from config import TILES_DIR, BITMAPS_DIR, WGS84_DIR, LABELS_DIR, OUTPUT_DIR

def create_directories():
    """Create all the directories in the /data directories which are used for preprocessing/training/evaluating."""

    directories = [TILES_DIR, WATER_BITMAPS_DIR, WGS84_DIR, LABELS_DIR, OUTPUT_DIR]
    for directory in directories:
        save_makedirs(directory)

def save_makedirs(path):
    """Create a directory and don't throw an exception"""

    try:
        os.makedirs(path)
    except OSError as exception:
        if exception.errno != errno.EEXIST:
            raise


def get_file_name(file_path):
    """Extract the file name without the file extension from a file path."""

    basename = os.path.basename(file_path)
    # Make sure we don't include the file extension.
    return os.path.splitext(basename)[0]


def save_model_summary(hyperparameters, model, path):
    """Save the hyperparameters of a model and the model summary generated by keras to a .txt file."""

    with open(os.path.join(path, "hyperparameters.txt"), "wb") as out:
        for parameter, value in hyperparameters:
            out.write("{}: {}\n".format(parameter, value))

        # model.summary() prints to stdout. Because we want to write the
        # summary to a file we have to set the stdout to the file.
        stdout = sys.stdout
        sys.stdout = out
        model.summary()
        sys.stdout = stdout


def save_tiles(file_path, tiled_features, tiled_labels):
    """Save the tile data for a satellite image as a pickle."""

    print("Store tile data at {}.".format(file_path))
    with open(file_path, "wb") as out:
        pickle.dump({"features": tiled_features, "labels": tiled_labels}, out)


def load_bitmap(file_path):
    """Load a GeoTIFF which is a bitmap of our water and non-water features."""
    with rasterio.open(file_path) as src:
        bitmap = src.read(1)

    return bitmap

def save_bitmap(file_path, image, source):
    """Save a bitmap given as a 2D matrix as a GeoTIFF."""

    print("Save result at {}.".format(file_path))
    with rasterio.open(
            file_path,
            'w',
            driver='GTiff',
            dtype=rasterio.uint8,
            count=1,
            width=source.width,
            height=source.height,
            transform=source.transform) as dst:
        dst.write(image, indexes=1)

#
# def load_model(model_id):
#     """Load a keras model and its weights with the given ID."""
#
#     model_dir = os.path.join(MODELS_DIR, model_id)
#
#     print("Load model in {}.".format(model_dir))
#     model_file = os.path.join(model_dir, "model.json")
#     with open(model_file, "r") as f:
#         json_file = f.read()
#         model = keras.models.model_from_json(json_file)
#
#     weights_file = os.path.join(model_dir, "weights.hdf5")
#     model.load_weights(weights_file)
#
#     return model

def save_model(model, path):
    """Save a keras model and its weights at the given path."""

    print("Save trained model to {}.".format(path))
    model_path = os.path.join(path, "model.json")
    model_json = model.to_json()
    with open(model_path, "w") as json_file:
        json_file.write(model_json)

    weights_path = os.path.join(path, "weights.hdf5")
    model.save_weights(weights_path)


def load_input(img_features1):
    new_array_band = []
    for j in range(img_features1.__len__()):  # for each band
        new_array_in = np.empty(img_features1[0].__len__() * 64 * 64)
        for k in range(img_features1[j].__len__()):  # for each tile
            # unroll tile to array
            new_array_in[k * 4096:((k + 1) * 4096)] = np.ravel(img_features1[j][k][0])

        new_array_band = np.append(new_array_band, new_array_in)
    new_array = np.vstack(np.split(new_array_band, img_features1.__len__()))

    return new_array


def load_output(bitmap_tiles1):
    new_array_in = np.empty(bitmap_tiles1.__len__() * 64 * 64)
    for k in range(bitmap_tiles1.__len__()):
        new_array_in[k * 4096:((k + 1) * 4096)] = np.ravel(bitmap_tiles1[k][0])

    return new_array_in
